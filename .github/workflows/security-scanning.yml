name: Security & Vulnerability Scanning

on:
  push:
    branches: [main, develop]
    paths:
      - 'server/package*.json'
      - 'server/src/**'
  pull_request:
    branches: [main]
    paths:
      - 'server/package*.json'
      - 'server/src/**'
  schedule:
    # Run security scans daily at 3 AM UTC
    - cron: '0 3 * * *'

env:
  NODE_ENV: test

jobs:
  dependency-vulnerability-scan:
    name: Dependency Vulnerability Scanning
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'
          cache-dependency-path: server/package-lock.json
      
      - name: Install dependencies
        run: |
          cd server
          npm ci --prefer-offline --no-audit
      
      - name: Run npm audit
        run: |
          cd server
          echo "ğŸ” Running npm audit for vulnerability scanning..."
          
          # Run audit and capture output
          npm audit --audit-level=moderate --json > ../audit-results.json 2>/dev/null || true
          
          # Parse and display results
          node -e "
            const fs = require('fs');
            
            try {
              const auditData = JSON.parse(fs.readFileSync('../audit-results.json', 'utf8'));
              
              console.log('ğŸ“Š NPM Audit Results:');
              console.log('========================');
              
              if (auditData.vulnerabilities) {
                const vulns = auditData.vulnerabilities;
                const severityCount = {
                  critical: 0,
                  high: 0,
                  moderate: 0,
                  low: 0,
                  info: 0
                };
                
                Object.values(vulns).forEach(vuln => {
                  if (vuln.severity && severityCount.hasOwnProperty(vuln.severity)) {
                    severityCount[vuln.severity]++;
                  }
                });
                
                console.log('Vulnerability Summary:');
                console.log(\`  ğŸ”´ Critical: \${severityCount.critical}\`);
                console.log(\`  ğŸŸ  High: \${severityCount.high}\`);
                console.log(\`  ğŸŸ¡ Moderate: \${severityCount.moderate}\`);
                console.log(\`  ğŸŸ¢ Low: \${severityCount.low}\`);
                console.log(\`  â„¹ï¸  Info: \${severityCount.info}\`);
                
                const totalVulns = Object.values(severityCount).reduce((a, b) => a + b, 0);
                
                if (totalVulns === 0) {
                  console.log('âœ… No vulnerabilities found');
                } else {
                  console.log(\`\\nğŸ“‹ Total vulnerabilities: \${totalVulns}\`);
                  
                  // Show details for critical and high vulnerabilities
                  if (severityCount.critical > 0 || severityCount.high > 0) {
                    console.log('\\nğŸš¨ Critical/High Severity Details:');
                    Object.entries(vulns).forEach(([name, vuln]) => {
                      if (vuln.severity === 'critical' || vuln.severity === 'high') {
                        console.log(\`  - \${name}: \${vuln.severity} (\${vuln.via ? vuln.via.join(', ') : 'direct'})\`);
                      }
                    });
                  }
                  
                  // Fail build for critical vulnerabilities
                  if (severityCount.critical > 0) {
                    console.log('\\nâŒ Build failed due to critical vulnerabilities');
                    process.exit(1);
                  }
                  
                  // Warn for high vulnerabilities
                  if (severityCount.high > 0) {
                    console.log('\\nâš ï¸  High severity vulnerabilities found - consider updating dependencies');
                  }
                }
                
              } else {
                console.log('âœ… No vulnerabilities detected');
              }
            } catch (error) {
              console.log('âš ï¸  Could not parse audit results:', error.message);
              console.log('âœ… Continuing with manual vulnerability check...');
            }
          "
      
      - name: Dependency License Compliance Check
        run: |
          cd server
          echo "ğŸ” Checking dependency license compliance..."
          
          node -e "
            const packageJson = require('./package.json');
            const packageLockJson = require('./package-lock.json');
            
            console.log('ğŸ“Š License Compliance Analysis:');
            console.log('===============================');
            
            // List of approved licenses
            const approvedLicenses = [
              'MIT',
              'ISC',
              'BSD',
              'BSD-2-Clause',
              'BSD-3-Clause',
              'Apache-2.0',
              'CC0-1.0',
              'Unlicense'
            ];
            
            // List of flagged licenses that need review
            const flaggedLicenses = [
              'GPL',
              'LGPL',
              'AGPL',
              'COPYLEFT'
            ];
            
            function checkDependencyLicenses() {
              const issues = [];
              const licenseStats = {};
              
              // Check main dependencies
              console.log('\\nğŸ“¦ Main Dependencies:');
              Object.entries(packageJson.dependencies || {}).forEach(([name, version]) => {
                try {
                  const depPackage = require(\`./node_modules/\${name}/package.json\`);
                  const license = depPackage.license || 'UNKNOWN';
                  
                  licenseStats[license] = (licenseStats[license] || 0) + 1;
                  
                  if (flaggedLicenses.some(flag => license.toUpperCase().includes(flag))) {
                    issues.push(\`ğŸš¨ \${name}: \${license} (flagged license)\`);
                  } else if (!approvedLicenses.includes(license) && license !== 'UNKNOWN') {
                    issues.push(\`âš ï¸  \${name}: \${license} (needs review)\`);
                  } else {
                    console.log(\`  âœ… \${name}: \${license}\`);
                  }
                } catch (error) {
                  console.log(\`  âš ï¸  \${name}: Could not determine license\`);
                }
              });
              
              console.log('\\nğŸ“Š License Statistics:');
              Object.entries(licenseStats)
                .sort(([,a], [,b]) => b - a)
                .forEach(([license, count]) => {
                  console.log(\`  \${license}: \${count} package(s)\`);
                });
              
              if (issues.length > 0) {
                console.log('\\nğŸš¨ License Issues Found:');
                issues.forEach(issue => console.log(\`  \${issue}\`));
                
                const criticalIssues = issues.filter(issue => issue.includes('ğŸš¨'));
                if (criticalIssues.length > 0) {
                  console.log('\\nâŒ Critical license issues found - manual review required');
                  // Don't fail build for license issues, just warn
                  console.log('âš ï¸  Please review flagged licenses before production deployment');
                }
              } else {
                console.log('\\nâœ… All dependencies have approved licenses');
              }
            }
            
            checkDependencyLicenses();
          "
      
      - name: Outdated Dependencies Check
        run: |
          cd server
          echo "ğŸ” Checking for outdated dependencies..."
          
          # Check for outdated packages
          npm outdated --json > ../outdated.json 2>/dev/null || true
          
          node -e "
            const fs = require('fs');
            
            try {
              const outdatedData = fs.readFileSync('../outdated.json', 'utf8');
              
              if (outdatedData.trim()) {
                const outdated = JSON.parse(outdatedData);
                
                console.log('ğŸ“Š Outdated Dependencies Analysis:');
                console.log('==================================');
                
                if (Object.keys(outdated).length === 0) {
                  console.log('âœ… All dependencies are up to date');
                } else {
                  console.log('ğŸ“¦ Outdated packages found:');
                  
                  const majorUpdates = [];
                  const minorUpdates = [];
                  const patchUpdates = [];
                  
                  Object.entries(outdated).forEach(([name, info]) => {
                    const current = info.current;
                    const latest = info.latest;
                    
                    console.log(\`  ğŸ“¦ \${name}: \${current} â†’ \${latest}\`);
                    
                    // Categorize by semver change
                    const currentParts = current.replace(/[^\\d\\.]/g, '').split('.').map(Number);
                    const latestParts = latest.replace(/[^\\d\\.]/g, '').split('.').map(Number);
                    
                    if (latestParts[0] > currentParts[0]) {
                      majorUpdates.push(name);
                    } else if (latestParts[1] > currentParts[1]) {
                      minorUpdates.push(name);
                    } else {
                      patchUpdates.push(name);
                    }
                  });
                  
                  console.log('\\nğŸ“Š Update Categories:');
                  console.log(\`  ğŸ”´ Major updates (\${majorUpdates.length}): \${majorUpdates.join(', ') || 'none'}\`);
                  console.log(\`  ğŸŸ¡ Minor updates (\${minorUpdates.length}): \${minorUpdates.join(', ') || 'none'}\`);
                  console.log(\`  ğŸŸ¢ Patch updates (\${patchUpdates.length}): \${patchUpdates.join(', ') || 'none'}\`);
                  
                  if (majorUpdates.length > 0) {
                    console.log('\\nâš ï¸  Major updates available - review breaking changes before updating');
                  }
                  
                  if (minorUpdates.length + patchUpdates.length > 0) {
                    console.log('\\nğŸ’¡ Consider updating minor/patch versions for security and bug fixes');
                  }
                }
              } else {
                console.log('âœ… All dependencies are up to date');
              }
            } catch (error) {
              console.log('âœ… No outdated dependencies detected or error parsing results');
            }
          "
      
      - name: Security Headers and Configuration Check
        run: |
          cd server
          echo "ğŸ” Checking security configuration and headers..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            console.log('ğŸ“Š Security Configuration Analysis:');
            console.log('===================================');
            
            // Check package.json for security-related configurations
            const packageJson = require('./package.json');
            
            console.log('\\nğŸ”’ Package Security Configuration:');
            
            // Check for private flag
            if (packageJson.private) {
              console.log('  âœ… Package marked as private');
            } else {
              console.log('  âš ï¸  Package not marked as private - consider adding \"private\": true');
            }
            
            // Check engines specification
            if (packageJson.engines && packageJson.engines.node) {
              console.log(\`  âœ… Node.js version specified: \${packageJson.engines.node}\`);
            } else {
              console.log('  âš ï¸  Node.js version not specified in engines field');
            }
            
            // Check for security-related dependencies
            const securityDeps = ['cors', 'helmet'];
            console.log('\\nğŸ›¡ï¸  Security Dependencies:');
            securityDeps.forEach(dep => {
              if (packageJson.dependencies && packageJson.dependencies[dep]) {
                console.log(\`  âœ… \${dep}: \${packageJson.dependencies[dep]}\`);
              } else {
                console.log(\`  âš ï¸  \${dep}: Not found (consider adding for production)\`);
              }
            });
            
            // Check TypeScript configuration
            if (fs.existsSync('./tsconfig.json')) {
              const tsConfig = JSON.parse(fs.readFileSync('./tsconfig.json', 'utf8'));
              
              console.log('\\nğŸ“ TypeScript Security Configuration:');
              
              if (tsConfig.compilerOptions) {
                const securityOptions = {
                  strict: 'Strict type checking',
                  noImplicitAny: 'No implicit any types',
                  strictNullChecks: 'Strict null checks',
                  noImplicitReturns: 'No implicit returns'
                };
                
                Object.entries(securityOptions).forEach(([option, description]) => {
                  if (tsConfig.compilerOptions[option]) {
                    console.log(\`  âœ… \${option}: enabled (\${description})\`);
                  } else {
                    console.log(\`  âš ï¸  \${option}: disabled (\${description})\`);
                  }
                });
              }
            }
            
            // Check for sensitive files
            console.log('\\nğŸ” Sensitive Files Check:');
            const sensitivePatterns = [
              '.env',
              '.env.local',
              '.env.production',
              '*.key',
              '*.pem',
              '*.p12',
              'secrets.json',
              'config/secrets.js'
            ];
            
            let foundSensitive = false;
            sensitivePatterns.forEach(pattern => {
              const files = require('glob').sync(pattern, { ignore: 'node_modules/**' });
              if (files.length > 0) {
                console.log(\`  ğŸš¨ Found sensitive files: \${files.join(', ')}\`);
                foundSensitive = true;
              }
            });
            
            if (!foundSensitive) {
              console.log('  âœ… No sensitive files found in repository');
            }
            
            console.log('\\nâœ… Security configuration check completed');
          " 2>/dev/null || echo "âš ï¸ Glob not available, skipping sensitive files check"
      
      - name: Code Quality Security Analysis
        run: |
          cd server
          echo "ğŸ” Running code quality security analysis..."
          
          node -e "
            const fs = require('fs');
            const path = require('path');
            
            console.log('ğŸ“Š Code Quality Security Analysis:');
            console.log('==================================');
            
            // Security patterns to check for
            const securityPatterns = [
              { pattern: /eval\\s*\\(/, description: 'Use of eval() function', severity: 'high' },
              { pattern: /innerHTML\\s*=/, description: 'Direct innerHTML assignment', severity: 'medium' },
              { pattern: /document\\.write\\s*\\(/, description: 'Use of document.write', severity: 'medium' },
              { pattern: /\\$\\{[^}]*\\}/, description: 'Template literal (check for XSS)', severity: 'info' },
              { pattern: /password\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded password', severity: 'critical' },
              { pattern: /api[_-]?key\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded API key', severity: 'critical' },
              { pattern: /secret\\s*=\\s*['\"][^'\"]*['\"]/i, description: 'Hardcoded secret', severity: 'critical' },
              { pattern: /process\\.env\\[['\"](\\w*(?:password|secret|key)\\w*)['\"]/i, description: 'Environment variable access', severity: 'info' }
            ];
            
            function scanFile(filePath) {
              try {
                const content = fs.readFileSync(filePath, 'utf8');
                const lines = content.split('\\n');
                const issues = [];
                
                lines.forEach((line, index) => {
                  securityPatterns.forEach(({ pattern, description, severity }) => {
                    if (pattern.test(line)) {
                      issues.push({
                        file: filePath,
                        line: index + 1,
                        description,
                        severity,
                        code: line.trim()
                      });
                    }
                  });
                });
                
                return issues;
              } catch (error) {
                return [];
              }
            }
            
            function scanDirectory(dir) {
              let allIssues = [];
              
              try {
                const items = fs.readdirSync(dir);
                
                items.forEach(item => {
                  const fullPath = path.join(dir, item);
                  const stat = fs.statSync(fullPath);
                  
                  if (stat.isDirectory() && item !== 'node_modules' && item !== 'dist') {
                    allIssues = allIssues.concat(scanDirectory(fullPath));
                  } else if (stat.isFile() && (item.endsWith('.ts') || item.endsWith('.js'))) {
                    allIssues = allIssues.concat(scanFile(fullPath));
                  }
                });
              } catch (error) {
                // Ignore errors for inaccessible directories
              }
              
              return allIssues;
            }
            
            // Scan the src directory
            const issues = scanDirectory('./src');
            
            if (issues.length === 0) {
              console.log('âœ… No security issues detected in code');
            } else {
              console.log(\`ğŸ” Found \${issues.length} potential security issue(s):\\n\`);
              
              const severityOrder = { critical: 1, high: 2, medium: 3, low: 4, info: 5 };
              issues.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);
              
              let criticalCount = 0;
              let highCount = 0;
              
              issues.forEach(issue => {
                const icon = {
                  critical: 'ğŸš¨',
                  high: 'ğŸ”´',
                  medium: 'ğŸŸ¡',
                  low: 'ğŸŸ¢',
                  info: 'â„¹ï¸'
                }[issue.severity];
                
                console.log(\`\${icon} \${issue.severity.toUpperCase()}: \${issue.description}\`);
                console.log(\`   File: \${issue.file}:\${issue.line}\`);
                console.log(\`   Code: \${issue.code}\`);
                console.log('');
                
                if (issue.severity === 'critical') criticalCount++;
                if (issue.severity === 'high') highCount++;
              });
              
              console.log('ğŸ“Š Summary:');
              console.log(\`   Critical: \${criticalCount}\`);
              console.log(\`   High: \${highCount}\`);
              console.log(\`   Other: \${issues.length - criticalCount - highCount}\`);
              
              if (criticalCount > 0) {
                console.log('\\nâŒ Critical security issues found - immediate action required');
                process.exit(1);
              } else if (highCount > 0) {
                console.log('\\nâš ï¸  High severity security issues found - review recommended');
              }
            }
            
            console.log('\\nâœ… Code quality security analysis completed');
          "
      
      - name: Generate Security Report
        run: |
          echo "ğŸ“Š Security Scanning Summary Report"
          echo "===================================="
          echo ""
          echo "ğŸ” Scans Completed:"
          echo "  âœ… NPM Audit (dependency vulnerabilities)"
          echo "  âœ… License Compliance Check"
          echo "  âœ… Outdated Dependencies Analysis"
          echo "  âœ… Security Configuration Review"
          echo "  âœ… Code Quality Security Analysis"
          echo ""
          echo "ğŸ“‹ Key Security Metrics:"
          
          # Check if audit results exist
          if [ -f "../audit-results.json" ]; then
            echo "  ğŸ“Š Dependency vulnerabilities: See audit results above"
          else
            echo "  ğŸ“Š Dependency vulnerabilities: No issues detected"
          fi
          
          echo "  ğŸ”’ Security configuration: Reviewed"
          echo "  ğŸ“ Code quality: Analyzed for security patterns"
          echo ""
          echo "ğŸ’¡ Recommendations:"
          echo "  1. Regularly update dependencies to latest secure versions"
          echo "  2. Monitor security advisories for used packages"
          echo "  3. Review and approve any new dependencies before adding"
          echo "  4. Keep security scanning as part of CI/CD pipeline"
          echo "  5. Consider adding additional security tools like Snyk or CodeQL"
          echo ""
          echo "âœ… Security scanning completed successfully"
      
      - name: Upload Security Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: security-scan-results-${{ github.sha }}
          path: |
            audit-results.json
            outdated.json
          retention-days: 30